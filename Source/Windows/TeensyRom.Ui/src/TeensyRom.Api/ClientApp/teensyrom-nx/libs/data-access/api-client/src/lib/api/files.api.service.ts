/**
 * TeensyRom.Api | v1
 *
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core';
import {
  HttpClient,
  HttpHeaders,
  HttpParams,
  HttpResponse,
  HttpEvent,
  HttpParameterCodec,
  HttpContext,
} from '@angular/common/http';
import { CustomHttpParameterCodec } from '../encoder';
import { Observable } from 'rxjs';

// @ts-ignore
import { GetDirectoryResponse } from '../model/getDirectoryResponse';
// @ts-ignore
import { IndexAllResponse } from '../model/indexAllResponse';
// @ts-ignore
import { IndexResponse } from '../model/indexResponse';
// @ts-ignore
import { LaunchFileResponse } from '../model/launchFileResponse';
// @ts-ignore
import { LaunchRandomResponse } from '../model/launchRandomResponse';
// @ts-ignore
import { ProblemDetails } from '../model/problemDetails';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';
import { BaseService } from '../api.base.service';

@Injectable({
  providedIn: 'any',
})
export class FilesApiService extends BaseService {
  constructor(
    protected httpClient: HttpClient,
    @Optional() @Inject(BASE_PATH) basePath: string | string[],
    @Optional() configuration?: Configuration
  ) {
    super(basePath, configuration);
  }

  /**
   * Get Directory
   * Gets a directory for given storage device.  - Returns metadata for all files in the directory. - This is not recursive and will only include the files for the requested directory. - Make another request to get subdirectory content.
   * @param deviceId
   * @param storageType
   * @param path
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getDirectory(
    deviceId: string,
    storageType: number,
    path?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/problem+json';
      context?: HttpContext;
      transferCache?: boolean;
    }
  ): Observable<GetDirectoryResponse>;
  public getDirectory(
    deviceId: string,
    storageType: number,
    path?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/problem+json';
      context?: HttpContext;
      transferCache?: boolean;
    }
  ): Observable<HttpResponse<GetDirectoryResponse>>;
  public getDirectory(
    deviceId: string,
    storageType: number,
    path?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/problem+json';
      context?: HttpContext;
      transferCache?: boolean;
    }
  ): Observable<HttpEvent<GetDirectoryResponse>>;
  public getDirectory(
    deviceId: string,
    storageType: number,
    path?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/problem+json';
      context?: HttpContext;
      transferCache?: boolean;
    }
  ): Observable<any> {
    if (deviceId === null || deviceId === undefined) {
      throw new Error(
        'Required parameter deviceId was null or undefined when calling getDirectory.'
      );
    }
    if (storageType === null || storageType === undefined) {
      throw new Error(
        'Required parameter storageType was null or undefined when calling getDirectory.'
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>path, 'Path');

    let localVarHeaders = this.defaultHeaders;

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', 'application/problem+json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/devices/${this.configuration.encodeParam({
      name: 'deviceId',
      value: deviceId,
      in: 'path',
      style: 'simple',
      explode: false,
      dataType: 'string',
      dataFormat: undefined,
    })}/storage/${this.configuration.encodeParam({
      name: 'storageType',
      value: storageType,
      in: 'path',
      style: 'simple',
      explode: false,
      dataType: 'number',
      dataFormat: undefined,
    })}/directories`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<GetDirectoryResponse>('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * Index
   * Indexes the directory structure of a given TeensyROM device and storage type.  - Providing a path will index starting at that directory and all subdirectories below it. - Providing no path will index the whole storage device. - Don\&#39;t touch your commodore while indexing is in progress.
   * @param deviceId
   * @param storageType
   * @param startingPath
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public index(
    deviceId: string,
    storageType: number,
    startingPath?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/problem+json';
      context?: HttpContext;
      transferCache?: boolean;
    }
  ): Observable<IndexResponse>;
  public index(
    deviceId: string,
    storageType: number,
    startingPath?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/problem+json';
      context?: HttpContext;
      transferCache?: boolean;
    }
  ): Observable<HttpResponse<IndexResponse>>;
  public index(
    deviceId: string,
    storageType: number,
    startingPath?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/problem+json';
      context?: HttpContext;
      transferCache?: boolean;
    }
  ): Observable<HttpEvent<IndexResponse>>;
  public index(
    deviceId: string,
    storageType: number,
    startingPath?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/problem+json';
      context?: HttpContext;
      transferCache?: boolean;
    }
  ): Observable<any> {
    if (deviceId === null || deviceId === undefined) {
      throw new Error('Required parameter deviceId was null or undefined when calling index.');
    }
    if (storageType === null || storageType === undefined) {
      throw new Error('Required parameter storageType was null or undefined when calling index.');
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>startingPath,
      'StartingPath'
    );

    let localVarHeaders = this.defaultHeaders;

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', 'application/problem+json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/devices/${this.configuration.encodeParam({
      name: 'deviceId',
      value: deviceId,
      in: 'path',
      style: 'simple',
      explode: false,
      dataType: 'string',
      dataFormat: undefined,
    })}/storage/${this.configuration.encodeParam({
      name: 'storageType',
      value: storageType,
      in: 'path',
      style: 'simple',
      explode: false,
      dataType: 'number',
      dataFormat: undefined,
    })}/index`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<IndexResponse>('post', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * Index All
   * Indexes all storage for all connected TeensyROM devices.  - This will recursively index all storage devices. - Multiple devices will be indexed in parallel, one device type at a time. - This could take a few minutes if you have a lot of data. - Don\&#39;t touch your commodores while indexing is in progress.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public indexAll(
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/problem+json';
      context?: HttpContext;
      transferCache?: boolean;
    }
  ): Observable<IndexAllResponse>;
  public indexAll(
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/problem+json';
      context?: HttpContext;
      transferCache?: boolean;
    }
  ): Observable<HttpResponse<IndexAllResponse>>;
  public indexAll(
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/problem+json';
      context?: HttpContext;
      transferCache?: boolean;
    }
  ): Observable<HttpEvent<IndexAllResponse>>;
  public indexAll(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/problem+json';
      context?: HttpContext;
      transferCache?: boolean;
    }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', 'application/problem+json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/files/index/all`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<IndexAllResponse>('post', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * Launch File
   * Launches a file given a valid path to a file stored on the TeensyRom.
   * @param deviceId
   * @param storageType
   * @param filePath
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public launchFile(
    deviceId: string,
    storageType: number,
    filePath: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/problem+json';
      context?: HttpContext;
      transferCache?: boolean;
    }
  ): Observable<LaunchFileResponse>;
  public launchFile(
    deviceId: string,
    storageType: number,
    filePath: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/problem+json';
      context?: HttpContext;
      transferCache?: boolean;
    }
  ): Observable<HttpResponse<LaunchFileResponse>>;
  public launchFile(
    deviceId: string,
    storageType: number,
    filePath: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/problem+json';
      context?: HttpContext;
      transferCache?: boolean;
    }
  ): Observable<HttpEvent<LaunchFileResponse>>;
  public launchFile(
    deviceId: string,
    storageType: number,
    filePath: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/problem+json';
      context?: HttpContext;
      transferCache?: boolean;
    }
  ): Observable<any> {
    if (deviceId === null || deviceId === undefined) {
      throw new Error('Required parameter deviceId was null or undefined when calling launchFile.');
    }
    if (storageType === null || storageType === undefined) {
      throw new Error(
        'Required parameter storageType was null or undefined when calling launchFile.'
      );
    }
    if (filePath === null || filePath === undefined) {
      throw new Error('Required parameter filePath was null or undefined when calling launchFile.');
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>filePath,
      'FilePath'
    );

    let localVarHeaders = this.defaultHeaders;

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', 'application/problem+json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/devices/${this.configuration.encodeParam({
      name: 'deviceId',
      value: deviceId,
      in: 'path',
      style: 'simple',
      explode: false,
      dataType: 'string',
      dataFormat: undefined,
    })}/storage/${this.configuration.encodeParam({
      name: 'storageType',
      value: storageType,
      in: 'path',
      style: 'simple',
      explode: false,
      dataType: 'number',
      dataFormat: undefined,
    })}/launch`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<LaunchFileResponse>('post', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * Launch Random File
   * Launches a random file given a device, storage, filter and starting directory location.  - Starting Directory: Starting directory to look for a random file. - Scope: &#x60;Storage&#x60; - Selects a random file anywhere on the specified storage device. - Scope: &#x60;DirDeep&#x60; - Selects a random file from the starting directory or any of its subdirectories. - Scope: &#x60;DirShallow&#x60; - Selects a random file from the starting directory only (subdirectories are not included). - Filter: &#x60;All&#x60; - Any file type will be randomly selected. - Filter: &#x60;Games&#x60; - Only game-related files will be selected (e.g., .prg, .crt, .d64, etc). Includes demos and non-games. - Filter: &#x60;Music&#x60; - Only music or song files will be selected (e.g., .sid, .mus, .mp3, etc). - Filter: &#x60;Images&#x60; - Only image files will be selected (e.g., .koa, .png, etc). Also includes text files (may be improved in a future release)
   * @param deviceId
   * @param storageType
   * @param filterType
   * @param scope
   * @param startingDirectory
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public launchRandom(
    deviceId: string,
    storageType: number,
    filterType?: number,
    scope?: number,
    startingDirectory?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/problem+json';
      context?: HttpContext;
      transferCache?: boolean;
    }
  ): Observable<LaunchRandomResponse>;
  public launchRandom(
    deviceId: string,
    storageType: number,
    filterType?: number,
    scope?: number,
    startingDirectory?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/problem+json';
      context?: HttpContext;
      transferCache?: boolean;
    }
  ): Observable<HttpResponse<LaunchRandomResponse>>;
  public launchRandom(
    deviceId: string,
    storageType: number,
    filterType?: number,
    scope?: number,
    startingDirectory?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/problem+json';
      context?: HttpContext;
      transferCache?: boolean;
    }
  ): Observable<HttpEvent<LaunchRandomResponse>>;
  public launchRandom(
    deviceId: string,
    storageType: number,
    filterType?: number,
    scope?: number,
    startingDirectory?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/problem+json';
      context?: HttpContext;
      transferCache?: boolean;
    }
  ): Observable<any> {
    if (deviceId === null || deviceId === undefined) {
      throw new Error(
        'Required parameter deviceId was null or undefined when calling launchRandom.'
      );
    }
    if (storageType === null || storageType === undefined) {
      throw new Error(
        'Required parameter storageType was null or undefined when calling launchRandom.'
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>filterType,
      'FilterType'
    );
    localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>scope, 'Scope');
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>startingDirectory,
      'StartingDirectory'
    );

    let localVarHeaders = this.defaultHeaders;

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', 'application/problem+json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/devices/${this.configuration.encodeParam({
      name: 'deviceId',
      value: deviceId,
      in: 'path',
      style: 'simple',
      explode: false,
      dataType: 'string',
      dataFormat: undefined,
    })}/storage/${this.configuration.encodeParam({
      name: 'storageType',
      value: storageType,
      in: 'path',
      style: 'simple',
      explode: false,
      dataType: 'number',
      dataFormat: undefined,
    })}/random-launch`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<LaunchRandomResponse>('post', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }
}
