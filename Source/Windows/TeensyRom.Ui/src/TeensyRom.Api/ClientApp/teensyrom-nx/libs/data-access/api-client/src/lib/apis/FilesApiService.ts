/* tslint:disable */
/* eslint-disable */
/**
 * TeensyRom.Api | v1
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import type {
  GetDirectoryResponse,
  IndexAllResponse,
  IndexResponse,
  LaunchFileResponse,
  LaunchRandomResponse,
  ProblemDetails,
  TeensyStorageType,
} from '../models/index';
import {
  GetDirectoryResponseFromJSON,
  GetDirectoryResponseToJSON,
  IndexAllResponseFromJSON,
  IndexAllResponseToJSON,
  IndexResponseFromJSON,
  IndexResponseToJSON,
  LaunchFileResponseFromJSON,
  LaunchFileResponseToJSON,
  LaunchRandomResponseFromJSON,
  LaunchRandomResponseToJSON,
  ProblemDetailsFromJSON,
  ProblemDetailsToJSON,
  TeensyStorageTypeFromJSON,
  TeensyStorageTypeToJSON,
} from '../models/index';

export interface GetDirectoryRequest {
  deviceId: string;
  storageType: TeensyStorageType;
  path?: string;
}

export interface IndexRequest {
  deviceId: string;
  storageType: TeensyStorageType;
  startingPath?: string;
}

export interface LaunchFileRequest {
  deviceId: string;
  storageType: TeensyStorageType;
  filePath: string;
}

export interface LaunchRandomRequest {
  deviceId: string;
  storageType: TeensyStorageType;
  filterType?: LaunchRandomFilterTypeEnum;
  scope?: LaunchRandomScopeEnum;
  startingDirectory?: string;
}

/**
 *
 */
export class FilesApiService extends runtime.BaseAPI {
  /**
   * Gets a directory for given storage device.  - Returns metadata for all files in the directory. - This is not recursive and will only include the files for the requested directory. - Make another request to get subdirectory content.
   * Get Directory
   */
  async getDirectoryRaw(
    requestParameters: GetDirectoryRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<GetDirectoryResponse>> {
    if (requestParameters['deviceId'] == null) {
      throw new runtime.RequiredError(
        'deviceId',
        'Required parameter "deviceId" was null or undefined when calling getDirectory().'
      );
    }

    if (requestParameters['storageType'] == null) {
      throw new runtime.RequiredError(
        'storageType',
        'Required parameter "storageType" was null or undefined when calling getDirectory().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['path'] != null) {
      queryParameters['Path'] = requestParameters['path'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/devices/{deviceId}/storage/{storageType}/directories`
          .replace(`{${'deviceId'}}`, encodeURIComponent(String(requestParameters['deviceId'])))
          .replace(
            `{${'storageType'}}`,
            encodeURIComponent(String(requestParameters['storageType']))
          ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      GetDirectoryResponseFromJSON(jsonValue)
    );
  }

  /**
   * Gets a directory for given storage device.  - Returns metadata for all files in the directory. - This is not recursive and will only include the files for the requested directory. - Make another request to get subdirectory content.
   * Get Directory
   */
  async getDirectory(
    requestParameters: GetDirectoryRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<GetDirectoryResponse> {
    const response = await this.getDirectoryRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Indexes the directory structure of a given TeensyROM device and storage type.  - Providing a path will index starting at that directory and all subdirectories below it. - Providing no path will index the whole storage device. - Don\'t touch your commodore while indexing is in progress.
   * Index
   */
  async indexRaw(
    requestParameters: IndexRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<IndexResponse>> {
    if (requestParameters['deviceId'] == null) {
      throw new runtime.RequiredError(
        'deviceId',
        'Required parameter "deviceId" was null or undefined when calling index().'
      );
    }

    if (requestParameters['storageType'] == null) {
      throw new runtime.RequiredError(
        'storageType',
        'Required parameter "storageType" was null or undefined when calling index().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['startingPath'] != null) {
      queryParameters['StartingPath'] = requestParameters['startingPath'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/devices/{deviceId}/storage/{storageType}/index`
          .replace(`{${'deviceId'}}`, encodeURIComponent(String(requestParameters['deviceId'])))
          .replace(
            `{${'storageType'}}`,
            encodeURIComponent(String(requestParameters['storageType']))
          ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => IndexResponseFromJSON(jsonValue));
  }

  /**
   * Indexes the directory structure of a given TeensyROM device and storage type.  - Providing a path will index starting at that directory and all subdirectories below it. - Providing no path will index the whole storage device. - Don\'t touch your commodore while indexing is in progress.
   * Index
   */
  async index(
    requestParameters: IndexRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<IndexResponse> {
    const response = await this.indexRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Indexes all storage for all connected TeensyROM devices.  - This will recursively index all storage devices. - Multiple devices will be indexed in parallel, one device type at a time. - This could take a few minutes if you have a lot of data. - Don\'t touch your commodores while indexing is in progress.
   * Index All
   */
  async indexAllRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<IndexAllResponse>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/files/index/all`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      IndexAllResponseFromJSON(jsonValue)
    );
  }

  /**
   * Indexes all storage for all connected TeensyROM devices.  - This will recursively index all storage devices. - Multiple devices will be indexed in parallel, one device type at a time. - This could take a few minutes if you have a lot of data. - Don\'t touch your commodores while indexing is in progress.
   * Index All
   */
  async indexAll(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<IndexAllResponse> {
    const response = await this.indexAllRaw(initOverrides);
    return await response.value();
  }

  /**
   * Launches a file given a valid path to a file stored on the TeensyRom.
   * Launch File
   */
  async launchFileRaw(
    requestParameters: LaunchFileRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<LaunchFileResponse>> {
    if (requestParameters['deviceId'] == null) {
      throw new runtime.RequiredError(
        'deviceId',
        'Required parameter "deviceId" was null or undefined when calling launchFile().'
      );
    }

    if (requestParameters['storageType'] == null) {
      throw new runtime.RequiredError(
        'storageType',
        'Required parameter "storageType" was null or undefined when calling launchFile().'
      );
    }

    if (requestParameters['filePath'] == null) {
      throw new runtime.RequiredError(
        'filePath',
        'Required parameter "filePath" was null or undefined when calling launchFile().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['filePath'] != null) {
      queryParameters['FilePath'] = requestParameters['filePath'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/devices/{deviceId}/storage/{storageType}/launch`
          .replace(`{${'deviceId'}}`, encodeURIComponent(String(requestParameters['deviceId'])))
          .replace(
            `{${'storageType'}}`,
            encodeURIComponent(String(requestParameters['storageType']))
          ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      LaunchFileResponseFromJSON(jsonValue)
    );
  }

  /**
   * Launches a file given a valid path to a file stored on the TeensyRom.
   * Launch File
   */
  async launchFile(
    requestParameters: LaunchFileRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<LaunchFileResponse> {
    const response = await this.launchFileRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Launches a random file given a device, storage, filter and starting directory location.  - Starting Directory: Starting directory to look for a random file. - Scope: `Storage` - Selects a random file anywhere on the specified storage device. - Scope: `DirDeep` - Selects a random file from the starting directory or any of its subdirectories. - Scope: `DirShallow` - Selects a random file from the starting directory only (subdirectories are not included). - Filter: `All` - Any file type will be randomly selected. - Filter: `Games` - Only game-related files will be selected (e.g., .prg, .crt, .d64, etc). Includes demos and non-games. - Filter: `Music` - Only music or song files will be selected (e.g., .sid, .mus, .mp3, etc). - Filter: `Images` - Only image files will be selected (e.g., .koa, .png, etc). Also includes text files (may be improved in a future release)
   * Launch Random File
   */
  async launchRandomRaw(
    requestParameters: LaunchRandomRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<LaunchRandomResponse>> {
    if (requestParameters['deviceId'] == null) {
      throw new runtime.RequiredError(
        'deviceId',
        'Required parameter "deviceId" was null or undefined when calling launchRandom().'
      );
    }

    if (requestParameters['storageType'] == null) {
      throw new runtime.RequiredError(
        'storageType',
        'Required parameter "storageType" was null or undefined when calling launchRandom().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['filterType'] != null) {
      queryParameters['FilterType'] = requestParameters['filterType'];
    }

    if (requestParameters['scope'] != null) {
      queryParameters['Scope'] = requestParameters['scope'];
    }

    if (requestParameters['startingDirectory'] != null) {
      queryParameters['StartingDirectory'] = requestParameters['startingDirectory'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/devices/{deviceId}/storage/{storageType}/random-launch`
          .replace(`{${'deviceId'}}`, encodeURIComponent(String(requestParameters['deviceId'])))
          .replace(
            `{${'storageType'}}`,
            encodeURIComponent(String(requestParameters['storageType']))
          ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      LaunchRandomResponseFromJSON(jsonValue)
    );
  }

  /**
   * Launches a random file given a device, storage, filter and starting directory location.  - Starting Directory: Starting directory to look for a random file. - Scope: `Storage` - Selects a random file anywhere on the specified storage device. - Scope: `DirDeep` - Selects a random file from the starting directory or any of its subdirectories. - Scope: `DirShallow` - Selects a random file from the starting directory only (subdirectories are not included). - Filter: `All` - Any file type will be randomly selected. - Filter: `Games` - Only game-related files will be selected (e.g., .prg, .crt, .d64, etc). Includes demos and non-games. - Filter: `Music` - Only music or song files will be selected (e.g., .sid, .mus, .mp3, etc). - Filter: `Images` - Only image files will be selected (e.g., .koa, .png, etc). Also includes text files (may be improved in a future release)
   * Launch Random File
   */
  async launchRandom(
    requestParameters: LaunchRandomRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<LaunchRandomResponse> {
    const response = await this.launchRandomRaw(requestParameters, initOverrides);
    return await response.value();
  }
}

/**
 * @export
 */
export const LaunchRandomFilterTypeEnum = {
  All: 'All',
  Games: 'Games',
  Music: 'Music',
  Hex: 'Hex',
  Images: 'Images',
} as const;
export type LaunchRandomFilterTypeEnum =
  (typeof LaunchRandomFilterTypeEnum)[keyof typeof LaunchRandomFilterTypeEnum];
/**
 * @export
 */
export const LaunchRandomScopeEnum = {
  Storage: 'Storage',
  DirDeep: 'DirDeep',
  DirShallow: 'DirShallow',
} as const;
export type LaunchRandomScopeEnum =
  (typeof LaunchRandomScopeEnum)[keyof typeof LaunchRandomScopeEnum];
